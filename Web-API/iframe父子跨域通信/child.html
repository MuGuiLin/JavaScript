<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selection Component</title>
    <style>
        :root {
            --primary-color: #1890ff;
            --hover-bg: #f5f5f5;
            --border-color: #e8e8e8;
            --text-color: #333;
            --secondary-text: #666;
            --item-height: 32px;
            /* Fixed height for virtual scroll */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            background: #fff;
            display: flex;
            flex-direction: column;
        }

        /* Container split */
        .container {
            display: flex;
            flex: 1;
            height: 100%;
            overflow: hidden;
        }

        .left-panel,
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 16px;
        }

        .left-panel {
            border-right: 1px solid var(--border-color);
        }

        /* Search */
        .search-box {
            margin-bottom: 12px;
            position: relative;
            flex-shrink: 0;
        }

        .search-box input {
            width: 100%;
            padding: 8px 30px 8px 30px;
            border: 1px solid #d9d9d9;
            border-radius: 4px;
            outline: none;
            font-size: 14px;
        }

        .search-box input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }

        .search-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
        }

        .clear-icon {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #FFF;
            cursor: pointer;
            display: none;
            font-size: 16px;
            background: #ddd;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            text-align: center;
            line-height: 16px;
        }

        .clear-icon:hover {
            color: red;
            background: #ccc;
        }

        /* Tree View - Virtual Scroll */
        .tree-viewport {
            flex: 1;
            overflow-y: auto;
            position: relative;
        }

        .tree-phantom {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            z-index: -1;
        }

        .tree-content {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
        }

        .tree-node {
            display: flex;
            align-items: center;
            height: var(--item-height);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        .tree-node:hover {
            background-color: var(--hover-bg);
        }

        .u-icon {
            margin: 0 6px;
            font-size: 16px;
            color: var(--primary-color);
        }

        .toggle-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            transition: transform 0.2s;
            font-size: 12px;
        }

        .toggle-icon.expanded {
            transform: rotate(90deg);
        }

        .toggle-icon.leaf {
            visibility: hidden;
        }

        /* Right Panel - Selected */
        .selected-header {
            font-size: 14px;
            color: #999;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .selected-list {
            flex: 1;
            overflow-y: auto;
        }

        .selected-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f9f9f9;
        }

        .selected-item:hover {
            background-color: var(--hover-bg);
        }

        .item-info {
            display: flex;
            align-items: center;
            overflow: hidden;
        }

        .item-info span:last-child {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .remove-btn {
            color: #999;
            cursor: pointer;
            font-size: 22px;
            margin-left: 10px;
            padding: 0 8px;
            flex-shrink: 0;
        }

        .remove-btn:hover {
            color: #ff4d4f;
        }

        .check-mark {
            color: var(--primary-color);
            font-weight: bold;
            margin-right: 8px;
            visibility: hidden;
        }

        .check-mark.checked {
            visibility: visible;
        }

        /* Loading */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #999;
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="left-panel">
            <div class="search-box">
                <span class="search-icon">üîç</span>
                <input type="text" placeholder="ÊêúÁ¥¢ ÈÉ®Èó®„ÄÅ‰∫∫Âëò" id="searchInput">
                <span class="clear-icon" id="clearBtn">√ó</span>
            </div>

            <div class="tree-viewport" id="treeViewport">
                <div class="loading" id="loading">Âä†ËΩΩ‰∏≠...</div>
                <div class="tree-phantom" id="treePhantom"></div>
                <div class="tree-content" id="treeContent"></div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <div class="selected-header">
                Â∑≤ÈÄâÊã©ÁöÑ‰∫∫Âëò (<span id="selectedCount">0</span>)
            </div>
            <div class="selected-list" id="selectedList">
                <!-- Selected items will be rendered here -->
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_URL = '/api/org-structure'; // Todo: ÁúüÂÆû‰∏äÁ∫øÊó∂‰øÆÊîπÊ≠§APIÂú∞ÂùÄ mock: /api/org-structure
        const USE_MOCK_SERVER = true;         // Todo: ÁúüÂÆû‰∏äÁ∫øÊó∂ËÆæ‰∏∫ false

        // --- MOCK SERVER SETUP ---
        if (USE_MOCK_SERVER) {
            (function () {
                console.log('--- Mock Server Enabled ---');

                // Helper to generate data
                function generateLargeData() {
                    console.log('Mock Server: Generating 10k data...');
                    const roots = [];
                    for (let i = 1; i <= 5; i++) {
                        const root = {
                            id: `root-${i}`,
                            name: `ÊÄªÈÉ®Êú∫ÊûÑ ${i}`,
                            type: 'dept',
                            expanded: false,
                            children: []
                        };
                        for (let j = 1; j <= 20; j++) {
                            const dept = {
                                id: `dept-${i}-${j}`,
                                name: `Á†îÂèëÈÉ®Èó® ${i}-${j}`,
                                type: 'dept',
                                expanded: false,
                                children: []
                            };
                            for (let k = 1; k <= 100; k++) {
                                const user = {
                                    id: `user-${i}-${j}-${k}`,
                                    name: `Â∑•Á®ãÂ∏à ${i}-${j}-${k}`,
                                    type: 'user',
                                    expanded: false,
                                    children: []
                                };
                                dept.children.push(user);
                            }
                            root.children.push(dept);
                        }
                        roots.push(root);
                    }
                    console.log('Mock Server: Data generated.');
                    return roots;
                }

                const mockData = generateLargeData();
                const OriginalXHR = window.XMLHttpRequest;

                // Patch XMLHttpRequest
                window.XMLHttpRequest = class MockXHR extends OriginalXHR {
                    constructor() {
                        super();
                        this._url = '';
                        this._method = '';
                    }

                    open(method, url) {
                        this._method = method;
                        this._url = url;
                        super.open(method, url);
                    }

                    send(body) {
                        if (this._url === API_URL) {
                            console.log(`Mock Server: Intercepted request to ${this._url}`);
                            // Simulate network delay
                            setTimeout(() => {
                                // We can't easily write to readonly properties of standard XHR, 
                                // but we can trigger events defined on 'this' instance.

                                // Create a response
                                const responseData = JSON.stringify(mockData);

                                // Define properties on this instance to override prototype getters if needed,
                                // or just set them if they are writable. 
                                // Note: In many browsers these are read-only.
                                Object.defineProperty(this, 'responseText', { value: responseData, writable: true });
                                Object.defineProperty(this, 'response', { value: responseData, writable: true });
                                Object.defineProperty(this, 'status', { value: 200, writable: true });
                                Object.defineProperty(this, 'readyState', { value: 4, writable: true });
                                Object.defineProperty(this, 'statusText', { value: 'OK', writable: true });

                                if (this.onreadystatechange) {
                                    this.onreadystatechange();
                                }
                                if (this.onload) {
                                    this.onload();
                                }
                            }, 500); // 500ms delay
                        } else {
                            // Pass through unknown requests
                            super.send(body);
                        }
                    }
                };
            })();
        }

        // --- CONSTANTS ---
        const ITEM_HEIGHT = 32;

        // --- State ---
        const state = {
            selectedIds: new Set(),
            selectedNodes: [],
            treeData: [],
            flatNodes: [],
            searchKeyword: '',
            scrollTop: 0
        };

        // --- DOM Elements ---
        const treeViewport = document.getElementById('treeViewport');
        const treePhantom = document.getElementById('treePhantom');
        const treeContent = document.getElementById('treeContent');
        const selectedListEl = document.getElementById('selectedList');
        const selectedCountEl = document.getElementById('selectedCount');
        const searchInput = document.getElementById('searchInput');
        const clearBtn = document.getElementById('clearBtn');
        const loadingEl = document.getElementById('loading');

        // --- Fetch Data (The "Real" Code) ---
        function fetchData() {
            loadingEl.style.display = 'block';

            const xhr = new XMLHttpRequest();
            xhr.open('GET', API_URL);
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    loadingEl.style.display = 'none';
                    if (xhr.status === 200) {
                        try {
                            const data = JSON.parse(xhr.responseText);
                            state.treeData = data;
                            state.flatNodes = flattenTree(state.treeData);
                            renderVirtualTree();
                        } catch (e) {
                            console.error('Failed to parse JSON', e);
                            alert('Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•');
                        }
                    } else {
                        console.error('API Error', xhr.status, xhr.statusText);
                        alert('Êï∞ÊçÆËØ∑Ê±ÇÂ§±Ë¥•');
                    }
                }
            };
            xhr.onerror = function () {
                loadingEl.style.display = 'none';
                console.error('Network Error');
                alert('ÁΩëÁªúÈîôËØØ');
            };
            xhr.send();
        }

        // --- Core Logic: Flatten Tree ---
        function flattenTree(nodes, level = 0, result = []) {
            for (const node of nodes) {
                result.push({ ...node, level });
                if (node.expanded && node.children && node.children.length > 0) {
                    flattenTree(node.children, level + 1, result);
                }
            }
            return result;
        }

        // --- Core Logic: Filtering ---
        function filterData(nodes, keyword) {
            const result = [];
            for (const node of nodes) {
                const isMatch = node.name.toLowerCase().includes(keyword.toLowerCase());

                let filteredChildren = [];
                let hasMatchingChildren = false;

                if (node.children && node.children.length > 0) {
                    filteredChildren = filterData(node.children, keyword);
                    hasMatchingChildren = filteredChildren.length > 0;
                }

                if (isMatch || hasMatchingChildren) {
                    const newNode = { ...node, children: filteredChildren };
                    if (hasMatchingChildren) {
                        newNode.expanded = true;
                    }
                    result.push(newNode);
                }
            }
            return result;
        }

        // --- Virtual Render ---
        function renderVirtualTree() {
            const viewportHeight = treeViewport.clientHeight;
            const totalHeight = state.flatNodes.length * ITEM_HEIGHT;

            treePhantom.style.height = `${totalHeight}px`;

            const scrollTop = treeViewport.scrollTop;
            const startIndex = Math.floor(scrollTop / ITEM_HEIGHT);
            const endIndex = Math.min(state.flatNodes.length, Math.ceil((scrollTop + viewportHeight) / ITEM_HEIGHT) + 1);

            const fragment = document.createDocumentFragment();

            for (let i = startIndex; i < endIndex; i++) {
                const flatNode = state.flatNodes[i];
                const nodeEl = createNodeElement(flatNode);
                fragment.appendChild(nodeEl);
            }

            treeContent.innerHTML = '';
            treeContent.appendChild(fragment);
            treeContent.style.transform = `translateY(${startIndex * ITEM_HEIGHT}px)`;
        }

        function createNodeElement(flatNode) {
            const row = document.createElement('div');
            row.className = 'tree-node';
            row.style.paddingLeft = `${flatNode.level * 20}px`;

            const toggleBtn = document.createElement('div');
            const hasChildren = flatNode.children && flatNode.children.length > 0;
            toggleBtn.className = `toggle-icon ${hasChildren ? (flatNode.expanded ? 'expanded' : '') : 'leaf'}`;
            toggleBtn.textContent = '‚ñ∂';
            toggleBtn.onclick = (e) => {
                e.stopPropagation();
                if (hasChildren) toggleNode(flatNode.id);
            };
            row.appendChild(toggleBtn);

            const icon = document.createElement('span');
            icon.className = `u-icon ${flatNode.type}`;
            icon.textContent = flatNode.type === 'dept' ? 'üìÇ' : 'üë§';
            row.appendChild(icon);

            const name = document.createElement('span');
            name.textContent = flatNode.name;
            name.style.flex = 1;
            name.style.marginLeft = '4px';
            row.appendChild(name);

            const isSelected = state.selectedIds.has(flatNode.id);
            const check = document.createElement('div');
            check.className = `check-mark ${isSelected ? 'checked' : ''}`;
            check.textContent = '‚úì';
            row.appendChild(check);

            row.onclick = () => {
                handleCheck(flatNode);
            };

            return row;
        }

        // --- Interaction Logic ---
        function toggleNode(id) {
            function toggle(nodes) {
                for (const node of nodes) {
                    if (node.id === id) {
                        node.expanded = !node.expanded;
                        return true;
                    }
                    if (node.children && toggle(node.children)) return true;
                }
                return false;
            }
            toggle(state.treeData);
            state.flatNodes = flattenTree(state.treeData);
            renderVirtualTree();
        }

        function handleCheck(node) {
            const id = node.id;
            if (state.selectedIds.has(id)) {
                state.selectedIds.delete(id);
                state.selectedNodes = state.selectedNodes.filter(n => n.id !== id);
            } else {
                state.selectedIds.add(id);
                state.selectedNodes.push({ id: node.id, name: node.name, type: node.type });
            }
            renderVirtualTree();
            renderSelectedList();
        }

        function renderSelectedList() {
            selectedCountEl.textContent = state.selectedIds.size;
            selectedListEl.innerHTML = '';

            const MAX_RENDER = 200;
            const itemsToRender = state.selectedNodes.slice(0, MAX_RENDER);

            const fragment = document.createDocumentFragment();
            itemsToRender.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selected-item';

                const info = document.createElement('div');
                info.className = 'item-info';

                const icon = document.createElement('span');
                icon.className = `u-icon ${node.type}`;
                icon.textContent = node.type === 'dept' ? 'üìÇ' : 'üë§';

                const name = document.createElement('span');
                name.textContent = node.name;
                name.style.marginLeft = '8px';

                info.appendChild(icon);
                info.appendChild(name);

                const remove = document.createElement('div');
                remove.className = 'remove-btn';
                remove.textContent = '√ó';
                remove.onclick = () => {
                    state.selectedIds.delete(node.id);
                    state.selectedNodes = state.selectedNodes.filter(n => n.id !== node.id);
                    renderVirtualTree();
                    renderSelectedList();
                };

                item.appendChild(info);
                item.appendChild(remove);
                fragment.appendChild(item);
            });

            if (state.selectedNodes.length > MAX_RENDER) {
                const more = document.createElement('div');
                more.style.padding = '8px';
                more.style.textAlign = 'center';
                more.style.color = '#999';
                more.textContent = `ËøòÊúâ ${state.selectedNodes.length - MAX_RENDER} ‰∏™È°πÊú™ÊòæÁ§∫...`;
                fragment.appendChild(more);
            }

            selectedListEl.appendChild(fragment);
        }

        // --- Search ---
        let debounceTimer = null;
        let originalData = null; // To store initial data after fetch

        searchInput.addEventListener('input', (e) => {
            const keyword = e.target.value.trim();
            if (keyword === state.searchKeyword) return;
            state.searchKeyword = keyword;

            if (debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                performSearch(keyword);
            }, 300);

            clearBtn.style.display = keyword ? 'block' : 'none';
        });

        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
            state.searchKeyword = '';
            clearBtn.style.display = 'none';
            performSearch('');
        });

        function performSearch(keyword) {
            // Need original data reference?
            // When we fetch, we should store a copy of the original data.
            // Let's modify fetchData to save originalData.
            if (!originalData) originalData = state.treeData; // Hack for now, better in fetchData

            // Correction: state.treeData IS the source of truth if we don't swap it.
            // But search needs to filter FROM the full dataset.
            // When we load data, we should set `originalData`.

            // If we are searching...
            if (!originalData && state.treeData.length > 0) {
                // First search?
                // Wait, originalData needs to be set when data loads.
            }

            if (!keyword) {
                state.treeData = originalData;
            } else {
                state.treeData = filterData(originalData, keyword);
            }
            state.flatNodes = flattenTree(state.treeData);
            treeViewport.scrollTop = 0;
            renderVirtualTree();
        }

        // Hook into fetch to save originalData
        const originalFetchSuccess = function (data) {
            originalData = data; // Keep reference to raw data
            state.treeData = data; // Deep clone? For now modification toggles internal state of referenced objs?
            // Actually, toggling modifies the object. If we filter, we create new objects.
            // So if we clear search, we might get back the collapsed unique objects or new ones?
            // Simplist: filterData assumes immutable source -> new objects.
            // toggleNode mutates state.treeData elements.
            // If we restore originalData, we restore the state it was last in?
            // Yes if referenced.
            state.flatNodes = flattenTree(state.treeData);
            renderVirtualTree();
        }

        // Redefine fetchData success block slightly to capture originalData
        // Override the previous fetchData function for simplicity in this full-write replacement
        // See 'fetchData' above... I need to update it in this string block.
        // I will change the fetchData function body in the big string above before outputting.

        // RE-WRITING fetchData in the string block above to include originalData assignment.
        // DONE in the block above (conceptually). 
        // Wait, I didn't edit the block above. I need to make sure the wrote code works.
        // Code above has:
        // const data = JSON.parse(xhr.responseText);
        // state.treeData = data;
        // ...
        // I need to add `originalData = data;` inside fetchData.
        // I'll do a quick replace in my head before sending the tool call...
        // Actually, I can just write the correct code.

        // --- Event Listeners ---
        treeViewport.addEventListener('scroll', () => {
            window.requestAnimationFrame(renderVirtualTree);
        });

        // --- Init ---
        fetchData(); // Load data on start

        // Ensure fetchData sets originalData.
        // I will sneakily update fetchData in the HTML I generate.

        // --- API (PostMessage) ---
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'GET_SELECTED_ITEMS') {
                const data = JSON.parse(JSON.stringify(state.selectedNodes));
                event.source.postMessage({
                    type: 'SELECTED_ITEMS_DATA',
                    data: data
                }, '*');
            }
        });

    </script>
    <script>
        // Patch fetchData to save originalData correctly
        // (Just overriding the function I defined above to be safe and clear)
        const _oldFetch = fetchData;
        fetchData = function () {
            loadingEl.style.display = 'block';
            const xhr = new XMLHttpRequest();
            xhr.open('GET', API_URL);
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    loadingEl.style.display = 'none';
                    if (xhr.status === 200) {
                        try {
                            const data = JSON.parse(xhr.responseText);
                            originalData = JSON.parse(JSON.stringify(data)); // Deep copy to serve as master
                            state.treeData = data;
                            state.flatNodes = flattenTree(state.treeData);
                            renderVirtualTree();
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }
            };
            xhr.send();
        }

        // Call it
        fetchData();
    </script>
</body>

</html>