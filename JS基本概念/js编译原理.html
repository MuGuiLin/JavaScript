<!DOCTYPE html>
<html>
	
	<head>
		<meta charset="UTF-8">
		<title>js编译原理</title>
		<link rel="stylesheet" type="text/css" href="../../public/css/base.css"/>
	</head>
	
	<body>
		<h1>js编译原理</h1><hr />
		<pre>
			
		<b>
			JavaScript 程序中的一段源代码在执行之前会经历三个步骤，统称为 编译:
			1、分词/词法分析： 词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义  词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。
				词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找.
			
			2、解析/语法分析：这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”。
			3、代码生成：将 AST 转换为可执行代码的过程称被称为代码生成（简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中）。
			如：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
			LHS 和 RHS 就是上面说的对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行
			
			词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。
			编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。
		</b>
		
		<b>一、编译原理</b>
			首先要清楚，任何JavaScript代码片段在执行前都要进行编译(Js代码分为两个阶段：编译阶段 和 执行阶段。)，然后做好执行他的准备，并且通常马上就会执行他。其中：
			
			<b>引擎：</b>从头到尾负责整个JavaScript程序的编译及执行过程；
			<b>编译器：</b>负责语法分析及代码生成；
			<b>作用域：</b>负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确认当前执行的代码对这些标识符的访问权限。
			
			<b>这三者如何协同工作？</b>
			
			例如 var a = 2;这段程序，一般认为这是一句声明，但引擎却认为这是两个完全不同的声明：一个由编译器在编译时处理，另一个则由引擎在运行时处理。
			
			这个变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对他赋值。
			
			<b>查找过程中，引擎会进行两种类型的查询：LHS查询、RHS查询。</b>
			
			LHS查询：试图找到变量的容器本身，从而可以对其赋值（当变量出现在赋值操作的左侧时进行，查找的目的是对变量进行赋值）；
			
			RHS查询：与简单的查找某个变量的值一样（当变量出现在赋值操作的非左侧时进行，目的是获取变量的值）。
			
		<b>二、作用域嵌套</b>
			JavaScript作为编程语言，最基本的功能之一就是能够存储变量当中的值。而一套设计良好的用来存储变量，并且之后可以方便地找到这些变量的规则，被称为作用域。
			当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（全局作用域）为止。
			
		<b>三、抛出异常</b>
			区分LHS和RHS是一件很重要的事，因为在变量还没有声明的情况下，这两种查询的行为是不一样的。
			
			LHS 和 RHS 就是上面说的对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行
			
			如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常；当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎（前提是程序运作在非‘严格模式’下）。
			
			严格模式禁止自动或隐式地创建全局变量。
			
			如果RHS查询找到了变量，但是接下来对这个变量的值进行不合理的操作的话，比如试图对要给非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫做 TypeError异常。
			
			ReferenceError跟作用于判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或者不合理的。
			
		<b>四、一个小测验</b>
			function foo(a){
			    var b = a;
			    return a + b;
			}
			
			var c = foo(2);
			这段程序有几处LHS查询？几处RHS查询？

			1. 找出所有的 LHS 查询（这里有 3 处！）
				c = ..; 、 a = 2 （隐式变量分配）、 b = ..
			
			2. 找出所有的 RHS 查询（这里有 4 处！）
				foo(2.. 、 = a; 、 a .. 、 .. b
		</pre>
	</body>
	
	<script type="text/javascript">
		function foo(a){
		    var b = a;
		    return a + b;
		}
		
		var c = foo(2);
		console.log(c);
		//这段程序有几处LHS查询？几处RHS查询？
	</script>
</html>
