<!DOCTYPE html>
<html>
	
	<head>
		<meta charset="UTF-8">
		<title>hack</title>
		<link rel="stylesheet" type="text/css" href="../../public/css/base.css"/>
	</head>
	
	<body>
		<h1>CSS & JS hack</h1><hr />
		<pre>
			
		<b>
			什么是CSS hack:
			
			由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。
			这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!
			
			<a href="http://developer.51cto.com/art/201303/384223.htm">史上最全的浏览器CSS&JS Hack手册</a>
			
		</b>
			hack是什么呢，它是用来针对浏览器在css解释上出现异常现象时，为了兼容各浏览器所使用的一种非常手段。
			由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。

		<b>一、应尽量避免hack的使用</b>
			
			　　很多人都存在一种投机取巧的观点——不兼容，用hack。因为这样省时省力。但这样下去，你永远都无法知道为什么这个浏览器比那个浏览器多出10个像素了，越来越多的不知道将导致你对css的迷惑。你将越来越依赖hack。
			
			　　其实浏览器都已经很接近标准了，比如很多时候IE中的一些问题，都是由于hasLayout属性产生的，触发hasLayout便能顺利解决问题。又比如双倍距bug，加上display:inline就能解决问题了，并不需要用到hack来取掉那一倍的宽度。
			
			　　投机取巧、为了省时省力而使用hack，将使csser对css、对浏览器特性（或者说是漏洞）的理解停滞不前！故，请应尽量避免hack的使用。
			
		<b>二、不要畏惧hack的使用</b>
			
			　　经常见到有人高声呼吁：千万不要使用hack，要做无hack安全绿色界面。
			
			　　我认为，这种过分极端的观点是错误的，这是一个误区。hack以及私有属性之所以被人挖掘并为高手所研究，正是因为它有其不可替代的价值。
			
			　　在一些特殊的情况下，不使用hack根本没有办法解决问题，比如要一个按钮上的文字在各主流浏览器中完美地垂直居中，如果没有hack，你能做 到吗？比如css仿框架，不使用hack，你能做到吗？当然，你会说你不需要做到那么极致，但亲爱的，老板要。但亲爱的，你能做到更好，为什么不呢？
			
			　　你说不要用它，那就是因为它有弊端了，忌用hack的人有何顾虑呢？目前我所听到的声音都属于以下三种：
			
			　　1. 向后兼容问题（就是说你的页面ie8兼容了，在ie9下搞不好因为你使用的hack而错乱）
			
			　　不可否认，类似的悲剧确实存在。ie6向ie7过度的时代，important声明大概害惨了一批人，ie7继承了ie6的很多bug，但却完全支持了用于ie6 hack的important声明，于是用important根本无法区分ie7和ff2。
			
			　　但——但——但——在你使用hack的时候去预测一下是否再出现这样的情况，便可知hack用不用得了。简单例举一下：ie6有3px bug，我用“_margin-right:-3px”来解决，这个下划线+属性的写法仅ie6支持，ie7不支持，其他任何浏览器都不支持。按照标准的 发展趋势来看，今后会有浏览器支持吗？今后会还浏览器出现这么极品这么囧的3px bug吗？这样的hack，不过是以ie6本身来制ie6本身，并不会对其他浏览器及其之后的浏览器造成影响。
			
			　　2. 如我之前所陈，使用hack可能致使csser依赖hack。
			
			　　这样的问题其实完全事在人为，不依赖hack很简单，我不去依赖就行了——尽、量、避、免、使、用、hack！
			
			　　3. 无法通过标准验证。
			
			　　乖乖，标准验证是为了什么呢？是为了让你所写的样式更加符合标准，你知道如何去标准就行了，浏览器并不标准的时候，我们还要钻破脑袋了去按照标准的方法做事。别傻了孩子，你会把制定标准的人活活气死的。
			
		<b>三、CSS hack分类</b>

				CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。
				属性前缀法(即类内部Hack)：例如 IE6能识别下划线"_"和星号" * "，IE7能识别星号" * "，但不能识别下划线"_"，IE6~IE10都认识"\9"，但firefox前述三个都不能认识。
				选择器前缀法(即选择器Hack)：例如 IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。
				IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： <!--[if IE]>IE浏览器显示的内容 <![endif]-->，针对IE6及以下版本： <!--[if lt IE 6]>只在IE6-显示的内容 <![endif]-->。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。
				　　
				CSS hack书写顺序，一般是将适用范围广、被识别能力强的CSS定义在前面。
		</pre>
	</body>
	
	<script type="text/javascript">
		//一、ES5中的作用域
			//先看代码：
			for(var i = 0; i < 10; i++){
				
			}
			console.log(i); //10
			
			//js这段代码，你觉得会输出什么？答案是10，熟悉java、C、C++的同学肯定有点诧异找不到i，为什么会这样呢？
			//因为js还是不同与java的，在ES5中，只有全局作用域和函数作用域，并没有块作用域，当然我们可以实现块作用域的功能。看下面代码:
			(function(){
				for(var j = 0; j < 10; j++){
				
				}
			})()
			//console.log(j); //j is not defined
			
			//这种写法叫做立即调用函数表达式（IIFE），这其实就创建了一个局部作用域，该作用域声明的变量只有在该函数块内有效，外部访问不了。这种写法的好处就是可以做到不污染全局变量(闭包就是如此)。 
			//这里还想再提一点，就是在ES5中，变量的声明问题，不是很严格，你可以直接采用a=10,来声明一个全局变量。如下：
			
			a = 100;
			console.log(a); //100
			
			//这里你可以不声明变量就去使用它，其实js帮你做了一件事。它会执行如下代码:
			
			var a = undefined;
			a = 100;
			console.log(a); //100
			
			//你可以试验一下，在函数中也可以做到不用声明变量直接使用，个人觉得这种灵活的做法不是很好。不过在ES6中，已经不推荐不声明变量就去使用的做法了。 
			//那么我们接下来来一点进阶的东西，就是变量提升。（ES5中的概念，ES6中新的用法不会出现变量提升），看代码:
			
			b = 123;
			(function(){
				console.log(b); //undefined
				var b = 456;
				console.log(b); //456
			})();
			
			//你猜输出什么？undefined,我们来看一下什么是变量提升，很简单，其实就是将变量的声明提升到函数的最上面。其实上面的代码在最后js在解释（Js代码分为两个阶段：编译阶段和执行阶段）【这里是编译阶段】的时候就会变成这个样子：
			
			var b = undefined;
				b = 123;
			(function(){
				var b = undefined;
				console.log(b); //undefined
				b = 456;
				console.log(b); //456
			})();
			
			//理解了变量提升是什么意思了吧，其实就是将声明提到了最前面，所以输出的是undefined，注：在ES6中就不存在了;
			
			
			
		//二、ES6中的作用域 
			//由于ES5中存在很多问题，所以在ES6中，用let替换了var的声明，不过为了兼容ES5你还是可以使用以前的var。不过还是建议使用let（在移动端ios5及以下的不能识别）
			//let为js添加了新的作用域就是块作用域。看代码：
			
			for(let k = 0; k < 20; k++){
				
			}
			//console.log(k); // k is not defined
			
			//输出 k is not defined, 这里，我们就完全可以使用java等语言，来理解变量的声明了，而且使用let声明的变量，在没声明时（在ES6 严格模式 'use strict'【IE9及以下，不支持严格模式】），是不可以使用的。
			
			c = 3;
			let c = 10;
			console.log(c); //c is not defined

			//将会输出c is not defined,为什么呢？阮一峰的ES6上这样说，只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
			//ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
			//当然他解释为什么的时候提到了暂时性死区,建议看一下他的ES6 http://es6.ruanyifeng.com/#docs/let
			//总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
			
			
			//因为ES6出现的时间不是很长，所以我们还是会遇到很多ES5的写法和用法，
			//所以了解JS es5 和 es6都很重要，不管是做前端还是后端，都会或多或少接触js，既然接触了，我们就要对它有深入的了解才行，不能仅仅停留在写function上面，另外前端已经不像以前的了，我还是很看好js的发展的。
	</script>
</html>
