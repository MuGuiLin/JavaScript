<!DOCTYPE html>
<html>
	
	<head>
		<meta charset="UTF-8">
		<title>js引擎之LHS RHS查询</title>
		<link rel="stylesheet" type="text/css" href="../../public/css/base.css"/>
	</head>
	
	<body>
		<h1>js引擎之LHS RHS查询</h1><hr />
		<pre>
			
		<b>
			JavaScript中在预编译后执行代码时对变量的查询分为LHS（Left-Hand-Side）查询和RHS(Right-Hand-Side)查询。
			
			JavaScript 程序中的一段源代码在执行之前会经历三个步骤，统称为 编译:
			1、分词/词法分析
			2、解析/语法分析
			3、代码生成
			
			如：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
			LHS 和 RHS 就是上面说的对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行。
		</b>
		
		<b>一、LHS 和 RHS</b>
			字面意思其实是 Left Hand Side和 Right Hand Side 即左手边和右手边
			一般可以理解为 赋值操作的左侧和右侧。
			
			LHS与RHS：javascript引擎的两种查找类型，含义是赋值操作的左侧与右侧。
			LHS:对哪个赋值就对哪个进行LHS引用，可以理解为赋值操作的目标（变量）。
			RHS:需要获取哪个变量的值，就对哪个变量的值进行RHS引用，理解为赋值操作的源头（值）。
						
			我的理解就是，一般在左边的需要被赋值（变量），就是LHS引用，右边需要寻找到他的值（值），就是RHS引用。
			
		如：	var a = 3; //全局变量
		
		变量的赋值过程：
			引擎 • 从头到尾负责整个 JavaScript 程序的编译及执行过程。
			
			编译器 • 引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。
			
			作用域 • 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查
			询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
			
		1. 遇到 var a ，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的
			集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
			用域的集合中声明一个新的变量，并命名为 a 。
			
		2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 3 这个赋值
			操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的
			变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。
			
			如果引擎最终找到了 a 变量，就会将 3 赋值给它。否则引擎就会举手示意并抛出一个异
			常！
			
		总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如
			果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对
			它赋值。
			
		编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是
			否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。
			在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS。
			
		换句话说，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

		RHS: 查询与简单地查找某个变量的值别无二致.
		LHS: 查询则是试图找到变量的容器本身，从而可以对其赋值。
		
		在概念上可以将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。
			
		<b>二、LHS 和 RHS有什么区别</b>
		
			在书写代码的时候我们无时无刻不在与作用域较劲，而引擎是如何在沿着作用域链把我们想要的东西查找出来的呢？这里就涉及到了L与R的区别。
    		通过字面意思就很容易理解L代表left R代表right。
    		
    		LHS与RHS查询我们可以先简单的区分为：查询在 = 号左边的变量时，引擎使用LHS，查询在 = 右边的变量时，引擎使用RHS。
    		
    		LHS查询出来的是变量的地址，方便进行形如a = 2的赋值操作，因为引擎根本不需要关心a里面存的是什么鬼，按照程序猿的要求把2塞给a就可以了，
    		
    		而RHS查询出来的是变量存储的值，以便形如 a = b的赋值操作，引擎同样不需要关心 b 放在内存的哪个“格子”，只需要知道格子里面放的什么就可以了。
  
  			当然， 根据 = 左右来区分LHS RHS是不全面的，因为我们很容易漏掉一些隐藏的LHS与RHS：
  			
  			var c = 3;  
			function a(b){  
			    console.log(b+c);  
			}  
			a(2);  
			
			在上面一段代码中，我们可以很明显的得出 c ...使用了LHS，console.log()中的b、c使用了RHS，
			但是在调用函数a、console.log的时候同样使用了RHS，参数b的赋值也同样使用了LHS,所以我们最好通过取值、取地址这两个行为来判断引擎使用的查询方式。
			
		<b>对于上面的代码，引擎与作用域是这样交流的：</b>
		 	引擎：对全局作用域说，我想找一下c变量，你见过他么？
			全局作用域：嗨，别提了，编译器那小子刚刚声明了它，拿去吧！
			
			引擎：太棒了！我现在要把3丢给他
		 	引擎：等一下，还有一个事情想麻烦你一下，我想对a函数进行引用，你知道她在哪里么？
		 	全局作用域：就是那个跟c一起被丢进来的家伙把？喏，在这里呢，给你。
		 	
		 	引擎：哈哈，太感谢了，这样我只需要把2.....。
		    a函数作用域：萨瓦迪卡，引擎，今天天气不错啊，一起出去玩吧！
		    
		 	引擎：别提了，我手头上忙的要死，对了，你碰到过一个叫b的么？
		    a函数作用域：哦，他是a函数的一个形参，我这刚好有，拿去用
		    
		 	引擎：够哥们，这样我只需要把2放到b里面，之后.....哎，小a,console你有么
		    a函数作用域：有有有，这是个内置对象，给你
		    
		 	引擎：哈哈，你一直这么靠谱，我找找，哎呦，真有log这个函数，我得赶紧引用他
			引擎：你看我这脑子，你能在帮我找一下b么，我得确认一下b的内容
		    a函数作用域：放心，看！b没有变过，放心
		    
		 	引擎：那最好了，就差最后一步了，做完喝酒去，你那里有没有c，交出来我请你一包辣条！
		    a函数作用域：真的么！我找找，嗯.....不行，我这里没有，你得去问问我大哥 全局作用域
		    
			引擎：全局作用域，不好意思，又来找你了，不知道你有没有c，我拿辣条跟你换
			全局作用域：看你累的满头大汗的，辣条你自己留着吧，c给你，做完快歇歇吧！
			
		 	引擎：么么哒，你最好了，晚上我请你吃饭！
		 	
    		看完上面的对话，不知道你对LHS RHS是否有了足够的了解，
    	需要注意的是：
    		当查找到全局作用域时，若还没有查找到要找的变量信息，若为LHS查询，会默认声明一个与请求的变量同名的全局变量，
    		而RHS则会抛出错误，当然，在严格模式下，LHS也同样会报错，这是需要注意的地方。
			
			

			这里的L和R是指赋值时候“=” 的左侧还是右侧，也就是说一个是做被赋值，一个是取值。 
			正如下面这个例子，对变量a的引用是一个LHS引用，而对值2的引用是RHS引用。
			
			var a = 2;
			
			当然，在js中赋值操作不仅仅限于“=”这种显式赋值。还有一些隐式的赋值，比如：
			
			function fn(a){
			    ...
			}
			fn(2);
			
			这个例子中，执行函数fn的时候对fn进行了RHS引用，而对fn函数进行调用的时候隐藏着一个将2赋值给形式参数a的过程，即a=2，这里有对a的LHS引用。

			
			
		<b>三、为什么要区分LHS引用和RHS引用</b>
			因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。
			
			这两种不同的引用方式的在对没有声明的变量的处理上是不同的。而这个不同之处对于我们编写代码和分析JS引擎报的错误是很有用处的。

			1、当对一个变量执行RHS查询时，如果遍历该变量所在处的词法作用域未能找到这个变量，JS引擎就会抛出 ReferenceError 错误如果成功查询到了这个变量，但是对这个变量执行不合理操作，比如对一个非数组的变量执行下标取值，JS引擎就会抛出 TypeError 错误。
			
			2、当对一个变量执行LHS查询时，同样在遍历作用域后无法找到该变量，在非ES5的严格模式下，系统就会自动在全局作用域中创建一个同名变量，并将引用转移到该新建的全局变量中。而在ES5的严格模式下，LHS查询失败时JS引擎会抛出一个同RHS一样的 ReferenceError 错误。
			
			因此，对LHS查询和RHS查询的仔细区分和理解无论是对JS执行过程本身的理解还是分析错误都是有所好处的。
			
		为什么区分RHS与LHS是一件重要的事情?

			因为在变量没有声明(在任何作用域都找不到该变量的情况下),这两种查询的行为是不一样的.
			
			function foo (a) {
			　　console.log(a + b);
			　　return a + b;
			}
			foo(2);
			
			第一次对b进行RHS查询是找不到该变量的.也就是说这是一个"未声明"的变量.
			
			如果在rhs的所有嵌套的作用域查询中都无法找到该变量,js引擎就会抛出一个ReferenceError异常. ReferenceError是一个重要的异常.
			
			相较之下， 当引擎执行 LHS 查询时， 如果在顶层（ 全局作用域） 中也无法找到目标变量，
			
			全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非 “ 严格模式” 下。
			
			“ 不， 这个变量之前并不存在， 但是我很热心地帮你创建了一个。”
			
			来自 你不知道的js
			
			
		<b>四、JavaScript异常类型</b>
			1.SyntaxError：解析代码时发生语法错误；
			2.ReferenceError：引用一个不存在的变量时发生错误； || 将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值；
			3.RangeError：当一个值超出有效 范围时发生的错。（数组长度为负数 || Number对象的方法参数超出范围 || 函数堆栈超过最大值）；
			4.TypeError：变量或参数不是预期类型时发生的错误。比如对字符串等原始类型的值使用new命令，就会抛出这种错误；因为new命令的参数应该是一个构造函数；
			5.URIError：URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数；
			6.EvalError：eval函数没有被正确执行时，会抛出这个错误，已经不再ES5中出现。
		
		
		<b>五、小结</b>
			作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。
			如果查找的目的是对变量进行赋值，就会使用 LHS 查询；如果目的是获取变量的值，就会用 RHS 查询。
			赋值操作会导致 LHS 查询。 = 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作, 即都会导致 LHS 查询。
			
			JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2 这样的声明会被分解成两个独立的步骤：
				1、首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
				2、接下来，a = 2会查询（LHS查询）变量 a 并对其进行赋值。
			
			LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后到达全局作用域，无论找到或没找到都将停止。
			不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。
		
		
		<b>四、一个小测验</b>
			function foo(a){
				var b = a;
				rerurn a + b;
			}
			var c = foo(2);
			
			以上代码中有3个LHS与4个RHS，分析如下：
			
			1. 找出所有的 LHS 查询（这里有 3 处！）
				c = ..; 、 a = 2 （隐式变量分配）、 b = ..
				
			2. 找出所有的 RHS 查询（这里有 4 处！）
				foo(2.. 、 = a; 、 a .. 、 .. b

			第一，var c中的c需要被赋值，在赋值操作的左侧，所以对c进行LHS引用 1L
			
			第二，变量c需要被赋值，他的值是foo(2),那么foo(2)的值是多少呢，需要查找foo(2)的值，在赋值操作的右侧，所以对foo(2)进行RHS引用 1R
			
			第三，隐含赋值操作，将2传递给function foo(a){……}函数的参数a，a在赋值操作的左侧，对a进行LHS引用 1L (RHS值的来源2是传过来的！！！)
			
			第四，var b=a;中，b需要被赋值，处在赋值操作的左侧，所以b进行的LHS，b的值将从a来，那么右侧的a的值从何而来呢？这就需要对赋值操作右侧的a进行RHS。 1L, 1R 
			
			第五，return a+b;中，需要找到a与b的值的来源，a与b都在赋值操作的右侧，才能得到a+b的值，所以对a与b都是进行RHS引用. 2R
			
			
			//为什么要区分LHS与RHS
			//因为在变量还没有声明(在任何作用域中都无法找到该变量)情况下，这两种查询行为是不一样的。
			
			function foo(a){
			    //console.log( a + b); //b is not defined
			    b = a;
			}
			foo(2);
			
			//以上代码对b进行RHS的时候无法找到该变量的值，则会抛出ReferenceError异常，如果是LHS找不到变量，非严格模式下，会在全局作用域中，创建一个具有该名称的变量，严格模式下，会抛出与RHS类似的异常。
			
			function init(a){
	            c = a + 3; 
	        }
	      	init(2);    
	      	console.log(c);//5
	      	
	  		//以上代码中，对c进行LHS没有找到该变量，在全局作用域中创建了一个同名的变量c，在函数init外部可以访问到c变量。
	  		
	  		//如果将代码更改为如下:
	  		
	  		function init(a){
	            var d = a + 3;
	        }
	       	init(2);    
	       	//console.log(d); //d is not defined
	       	
	       	//在function中定义了一个局部变量d，全局作用域中定义，控制台报错如图显示，窗口中没有任何输出
	       	
	       	//将代码改成如下：
	       	
	       	function init(a){
	            var e = a + 3;
	        }
	       	init(2);    
	      	console.log(window.e);//undefined
	      	
	      	//将代码改成如上所示，控制台并没有报错， 因为window.e作为window的一个属性访问，所以会返回undefined，而e作为一个变量没有定义的时候是会报错的
			 
		</pre>
	</body>
	
	<script type="text/javascript">
		function foo(a){
		    var b = a;
		    return a + b;
		}
		
		var c = foo(2);
		console.log(c);
		//这段程序有几处LHS查询？几处RHS查询？
		
		/*
		  	  以上代码中有3个LHS与4个RHS，分析如下：

			第一，var c中的c需要被赋值，在赋值操作的左侧，所以对c进行LHS引用
			
			第二，变量c需要被赋值，他的值是foo(2),那么foo(2)的值是多少呢，需要查找foo(2)的值，在赋值操作的右侧，所以对foo(2)进行RHS引用
			
			第三，隐含赋值操作，将2传递给function foo(a){……}函数的参数a，a在赋值操作的左侧，对a进行LHS引用
			
			第四，var b=a;中，b需要被赋值，处在赋值操作的左侧，所以b进行的LHS，b的值将从a来，那么右侧的a的值从何而来呢？这就需要对赋值操作右侧的a进行RHS。
			
			第五，return a+b;中，需要找到a与b的值的来源，a与b都在赋值操作的右侧，才能得到a+b的值，所以对a与b都是进行RHS引用
		*/
		
		
		//为什么要区分LHS与RHS
		//因为在变量还没有声明(在任何作用域中都无法找到该变量)情况下，这两种查询行为是不一样的。
		
		function foo(a){
		    //console.log( a + b); //b is not defined
		    b = a;
		}
		foo(2);
		
		//以上代码对b进行RHS的时候无法找到该变量的值，则会抛出ReferenceError异常，如果是LHS找不到变量，非严格模式下，会在全局作用域中，创建一个具有该名称的变量，严格模式下，会抛出与RHS类似的异常。
		
		function init(a){
            c = a + 3; 
        }
      	init(2);    
      	console.log(c);//5
      	
  		//以上代码中，对c进行LHS没有找到该变量，在全局作用域中创建了一个同名的变量c，在函数init外部可以访问到c变量。
  		
  		//如果将代码更改为如下:
  		
  		function init(a){
            var d = a + 3;
        }
       	init(2);    
       	//console.log(d); //d is not defined
       	
       	//在function中定义了一个局部变量d，全局作用域中定义，控制台报错如图显示，窗口中没有任何输出
       	
       	//将代码改成如下：
       	
       	function init(a){
            var e = a + 3;
        }
       	init(2);    
      	console.log(window.e);//undefined
      	
      	//将代码改成如上所示，控制台并没有报错， 因为window.e作为window的一个属性访问，所以会返回undefined，而e作为一个变量没有定义的时候是会报错的
	</script>
</html>
