<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Rect Drag, Rotate, and Resize with Handles and Border</title>
    <style>
        svg {
            border: 1px solid black;
        }

        rect {
            fill: lightblue;
            cursor: move;
        }

        .rotate-handle {
            fill: red;
            cursor: pointer;
        }

        .resize-handle {
            fill: blue;
        }

        /* 定义8个控制点的cursor样式 */
        .resize-handle.top-left {
            cursor: nwse-resize;
        }

        .resize-handle.top-right {
            cursor: nesw-resize;
        }

        .resize-handle.bottom-left {
            cursor: nesw-resize;
        }

        .resize-handle.bottom-right {
            cursor: nwse-resize;
        }

        .resize-handle.middle-left {
            cursor: ew-resize;
        }

        .resize-handle.middle-right {
            cursor: ew-resize;
        }

        .resize-handle.middle-top {
            cursor: ns-resize;
        }

        .resize-handle.middle-bottom {
            cursor: ns-resize;
        }

        .border-rect {
            fill: none;
            stroke: red;
            stroke-width: 2;
        }

        /* 初始隐藏控制手柄 */
        #control-handles {
            display: none;
        }
    </style>
</head>

<body>
    <svg width="500" height="500">
        <!-- Group containing the rectangle for movement and rotation -->
        <g id="group" transform="translate(150, 150) rotate(0)">
            <rect id="rect" width="100" height="60" />
        </g>

        <!-- Control handles group, independent of 'group' -->
        <g id="control-handles">
            <!-- Border rectangle for visual tracking, same size as the main rect -->
            <rect id="border-rect" class="border-rect" width="100" height="60" />
            <circle id="rotate-handle" class="rotate-handle" cx="150" cy="50" r="8" />
            <!-- 8 resize handles -->
            <circle class="resize-handle top-left" r="5" />
            <circle class="resize-handle top-right" r="5" />
            <circle class="resize-handle bottom-left" r="5" />
            <circle class="resize-handle bottom-right" r="5" />
            <circle class="resize-handle middle-left" r="5" />
            <circle class="resize-handle middle-right" r="5" />
            <circle class="resize-handle middle-top" r="5" />
            <circle class="resize-handle middle-bottom" r="5" />
        </g>
    </svg>

    <script>
        const svg = document.querySelector('svg');
        const rect = document.getElementById('rect');
        const group = document.getElementById('group');
        const controlHandles = document.getElementById('control-handles');
        const handle = document.getElementById('rotate-handle');
        const borderRect = document.getElementById('border-rect');

        const rotationData = {
            isRotating: false,
            isDragging: false,
            isResizing: false,
            activeHandle: null,
            startX: 0,
            startY: 0,
            startAngle: 0,
            currentRotation: 0,
            translateX: 150,
            translateY: 150,
            centerX: 50,
            centerY: 30,
            width: 100,
            height: 60
        };

        // 计算鼠标位置与矩形中心的角度
        function calculateAngle(x, y) {
            const dx = x - rotationData.translateX - rotationData.centerX;
            const dy = y - rotationData.translateY - rotationData.centerY;
            return Math.atan2(dy, dx) * 180 / Math.PI;
        }

        // 更新旋转、控制点位置和边框
        function updateHandlePositions() {
            const angleRad = rotationData.currentRotation * Math.PI / 180;

            // Sync control-handles transform with the main group
            controlHandles.setAttribute('transform', `translate(${rotationData.translateX}, ${rotationData.translateY}) rotate(${rotationData.currentRotation} ${rotationData.centerX} ${rotationData.centerY})`);

            // 更新旋转手柄位置
            const handleDistance = 90;
            const handleX = rotationData.centerX + Math.cos(angleRad) * handleDistance;
            const handleY = rotationData.centerY + Math.sin(angleRad) * handleDistance;
            handle.setAttribute('cx', handleX);
            handle.setAttribute('cy', handleY);

            // 设置8个控制点的位置
            const halfWidth = rotationData.width / 2;
            const halfHeight = rotationData.height / 2;

            controlHandles.querySelector('.top-left').setAttribute('cx', rotationData.centerX - halfWidth);
            controlHandles.querySelector('.top-left').setAttribute('cy', rotationData.centerY - halfHeight);
            controlHandles.querySelector('.top-right').setAttribute('cx', rotationData.centerX + halfWidth);
            controlHandles.querySelector('.top-right').setAttribute('cy', rotationData.centerY - halfHeight);
            controlHandles.querySelector('.bottom-left').setAttribute('cx', rotationData.centerX - halfWidth);
            controlHandles.querySelector('.bottom-left').setAttribute('cy', rotationData.centerY + halfHeight);
            controlHandles.querySelector('.bottom-right').setAttribute('cx', rotationData.centerX + halfWidth);
            controlHandles.querySelector('.bottom-right').setAttribute('cy', rotationData.centerY + halfHeight);

            controlHandles.querySelector('.middle-left').setAttribute('cx', rotationData.centerX - halfWidth);
            controlHandles.querySelector('.middle-left').setAttribute('cy', rotationData.centerY);
            controlHandles.querySelector('.middle-right').setAttribute('cx', rotationData.centerX + halfWidth);
            controlHandles.querySelector('.middle-right').setAttribute('cy', rotationData.centerY);
            controlHandles.querySelector('.middle-top').setAttribute('cx', rotationData.centerX);
            controlHandles.querySelector('.middle-top').setAttribute('cy', rotationData.centerY - halfHeight);
            controlHandles.querySelector('.middle-bottom').setAttribute('cx', rotationData.centerX);
            controlHandles.querySelector('.middle-bottom').setAttribute('cy', rotationData.centerY + halfHeight);
        }

        // 显示控制手柄
        rect.addEventListener('click', function (e) {
            e.stopPropagation();  // 防止事件冒泡到SVG
            controlHandles.style.display = 'block';
            updateHandlePositions();
        });

        // 隐藏控制手柄
        svg.addEventListener('click', function (e) {
            if (e.target !== rect) {
                controlHandles.style.display = 'none';
            }
        });

        // Rotation logic
        handle.addEventListener('mousedown', function (e) {
            rotationData.isRotating = true;
            rotationData.startX = e.clientX;
            rotationData.startY = e.clientY;
            rotationData.startAngle = calculateAngle(rotationData.startX, rotationData.startY);
            svg.style.cursor = 'move';
        });

        svg.addEventListener('mousemove', function (e) {
            if (rotationData.isRotating) {
                const angle = calculateAngle(e.clientX, e.clientY);
                const deltaAngle = angle - rotationData.startAngle;
                rotationData.currentRotation += deltaAngle;

                group.setAttribute('transform', `translate(${rotationData.translateX}, ${rotationData.translateY}) rotate(${rotationData.currentRotation} ${rotationData.centerX} ${rotationData.centerY})`);
                updateHandlePositions();
                rotationData.startAngle = angle;
            }
        });

        svg.addEventListener('mouseup', function () {
            rotationData.isRotating = false;
            rotationData.isDragging = false;
            svg.style.cursor = 'default';
        });
    </script>
</body>

</html>