<svg width="800" height="600" style="border: 1px solid black;">
    <!-- 矩形 -->
    <rect x="200" y="150" width="150" height="100" fill="blue" transform="rotate(0 275 200)" id="myRect"></rect>

    <!-- 控制点 -->
    <circle id="tl" r="5" fill="red" cursor="pointer" />
    <circle id="tr" r="5" fill="red" cursor="pointer" />
    <circle id="bl" r="5" fill="red" cursor="pointer" />
    <circle id="br" r="5" fill="red" cursor="pointer" />

    <!-- 旋转控制点 -->
    <circle id="rotate" r="5" fill="green" cursor="pointer" />
</svg>

<script>
    const svg = document.querySelector("svg");
    const rect = document.getElementById("myRect");
    const handles = {
        tl: document.getElementById("tl"), // 左上角
        tr: document.getElementById("tr"), // 右上角
        bl: document.getElementById("bl"), // 左下角
        br: document.getElementById("br"), // 右下角
    };
    const rotateHandle = document.getElementById("rotate");

    let isDragging = false;
    let activeHandle = null;
    let initialMousePos, initialRect, initialAngle, initialTransform;

    // 获取矩形的中心点
    function getRectCenter() {
        const bbox = rect.getBBox();
        const matrix = rect.getCTM();
        const center = svg.createSVGPoint();
        center.x = bbox.x + bbox.width / 2;
        center.y = bbox.y + bbox.height / 2;
        return center.matrixTransform(matrix);
    }

    // 获取鼠标位置在SVG中的点
    function getSVGPoint(event) {
        const point = svg.createSVGPoint();
        point.x = event.clientX;
        point.y = event.clientY;
        return point.matrixTransform(svg.getScreenCTM().inverse());
    }

    // 更新控制点位置
    function updateHandles() {
        const rectMatrix = rect.getCTM();
        const x = parseFloat(rect.getAttribute("x"));
        const y = parseFloat(rect.getAttribute("y"));
        const width = parseFloat(rect.getAttribute("width"));
        const height = parseFloat(rect.getAttribute("height"));

        const points = {
            tl: { x, y },
            tr: { x: x + width, y },
            bl: { x, y: y + height },
            br: { x: x + width, y: y + height },
            rotate: { x: x + width / 2, y: y - 30 }, // 旋转控制点在矩形顶部上方
        };

        Object.entries(handles).forEach(([key, handle]) => {
            const point = svg.createSVGPoint();
            point.x = points[key].x;
            point.y = points[key].y;
            const transformedPoint = point.matrixTransform(rectMatrix);
            handle.setAttribute("cx", transformedPoint.x);
            handle.setAttribute("cy", transformedPoint.y);
        });

        const rotatePoint = svg.createSVGPoint();
        rotatePoint.x = points.rotate.x;
        rotatePoint.y = points.rotate.y;
        const transformedRotatePoint = rotatePoint.matrixTransform(rectMatrix);
        rotateHandle.setAttribute("cx", transformedRotatePoint.x);
        rotateHandle.setAttribute("cy", transformedRotatePoint.y);
    }

    // 开始旋转
    rotateHandle.addEventListener("mousedown", (event) => {
        isDragging = true;
        activeHandle = "rotate";

        const center = getRectCenter();
        const mousePoint = getSVGPoint(event);
        initialAngle = Math.atan2(mousePoint.y - center.y, mousePoint.x - center.x);
        initialTransform = rect.getAttribute("transform");

        event.preventDefault();
    });

    // 拖动旋转
    svg.addEventListener("mousemove", (event) => {
        if (!isDragging || activeHandle !== "rotate") return;

        const center = getRectCenter();
        const mousePoint = getSVGPoint(event);
        const currentAngle = Math.atan2(mousePoint.y - center.y, mousePoint.x - center.x);
        const angleDelta = (currentAngle - initialAngle) * (180 / Math.PI);

        const transform = initialTransform.replace(
            /rotate\([^)]*\)/,
            `rotate(${angleDelta} ${center.x} ${center.y})`
        );
        rect.setAttribute("transform", transform);

        updateHandles();
    });

    // 开始调整宽高
    function startResize(event, handle) {
        isDragging = true;
        activeHandle = handle;

        initialMousePos = getSVGPoint(event);

        initialRect = {
            x: parseFloat(rect.getAttribute("x")),
            y: parseFloat(rect.getAttribute("y")),
            width: parseFloat(rect.getAttribute("width")),
            height: parseFloat(rect.getAttribute("height")),
        };

        event.preventDefault();
    }

    // 调整宽高
    svg.addEventListener("mousemove", (event) => {
        if (!isDragging || ["tl", "tr", "bl", "br"].indexOf(activeHandle) === -1) return;

        const currentMousePos = getSVGPoint(event);
        const dx = currentMousePos.x - initialMousePos.x;
        const dy = currentMousePos.y - initialMousePos.y;

        let { x, y, width, height } = initialRect;

        if (activeHandle === "tl") {
            x += dx;
            y += dy;
            width -= dx;
            height -= dy;
        } else if (activeHandle === "tr") {
            y += dy;
            width += dx;
            height -= dy;
        } else if (activeHandle === "bl") {
            x += dx;
            width -= dx;
            height += dy;
        } else if (activeHandle === "br") {
            width += dx;
            height += dy;
        }

        width = Math.max(10, width);
        height = Math.max(10, height);

        rect.setAttribute("x", x);
        rect.setAttribute("y", y);
        rect.setAttribute("width", width);
        rect.setAttribute("height", height);

        updateHandles();
    });

    // 结束调整
    document.addEventListener("mouseup", () => {
        isDragging = false;
        activeHandle = null;
    });

    // 初始更新
    updateHandles();
</script>