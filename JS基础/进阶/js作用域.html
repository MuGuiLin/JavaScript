<!DOCTYPE html>
<html>
	
	<head>
		<meta charset="UTF-8">
		<title>js作用域</title>
		<link rel="stylesheet" type="text/css" href="../../public/css/base.css"/>
	</head>
	
	<body>
		<h1>js作用域</h1><hr />
		<pre>
			
		<b>
			我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符(变量)名称进行变量查找。
			
			变量的声明应该距离使用的地方越近越好，并最大限度地本地化。
			
			任何程序设计语言都有作用域的概念，简单的说：作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期，在JavaScript中变量的作用域有全局作用域和局部作用域。

			单纯的JavaScript作用域还是很好理解的，在一些类C编程语言中花括号内的每一段代码都有各自的作用域，而且变量在声明它们的代码段外是不可见的，称之为块级的作用域，
			
			JavaScript容易让初学者误会的地方也在于此，JavaScript并没有块及的作用域（在ES6中有块级作用域了在{ }之间），只有函数级作用域：变量在声明它们的函数体及其子函数内是可见的。

			变量没有在函数内声明或者声明的时候没有带var就是全局变量，拥有全局作用域，window对象的所有属性拥有全局作用域；在代码任何地方都可以访问，
			
			函数内部声明并且以var修饰的变量就是局部变量，只能在函数体内使用，<i>函数的参数虽然没有使用var但仍然是局部变量</i>。
			
			还有一点儿容易让初学者迷惑的地方是JavaScript变量可函数的与解析或者声明提前，好多种叫法但说的是一件事情，
			
			JavaScript虽然是解释执行，但也不是按部就班逐句解释执行的，在真正解释执行之前，JavaScript解释器会预解析代码，将变量、函数声明部分提前解释，
			
			这就意味着我们可以在function声明语句之前调用function，这多数人习以为常，但是对于变量的与解析乍一看会很奇怪。
			
			JavaScript作为编程语言，最基本的功能之一就是能够存储变量当中的值。而一套设计良好的用来存储变量，并且之后可以方便地找到这些变量的规则，被称为作用域。
			
			JavaScript作用域 分为两种：一种是局部(function函数作用域，在ES6中有块级作用域了在{ }之间)、 另一种是全局(window)作用域。
		</b>
			1、全局：在JavaScript中全局变量的作用域比较简单，它的作用域是全局的，在代码的任何地方都是有定义（可获取、访问）的。
			2、局部：函数的参数和局部变量的作用域只在函数体内有定义（可获取、访问，如果是在ES6中的话，就是块级作用域了，它们在{ }之间，不是函数作用域了哦！）。
				(1)、函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。
				(2)、区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。
				(3)、如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
				(4)、函数声明 和 函数表达式 之间最重要的区别：是它们的名称标识符将会绑定在何处。
			
			<b>立即执行函数表达式</b>
				var a = 2;
				
				(function foo() {
					var a = 3;
					console.log( a ); // 3
				})();
				
				console.log( a ); // 2
				由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，
				比如 (function foo(){ .. })() 。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函。
			
			(function foo(){ .. }) 可以规避命名冲突，还可以隐藏内部实现【为什么“隐藏”变量和函数是一个有用的技术？有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。这个原则可以延伸到如何选择作用域来包含变量和函数。】
				
			3、另外局部变量的优先级要高于同名的全局变量,也就是说当局部变量与全局变量重名时，局部变量会覆盖全局变量（在ES6中 用let变量, const常量来定义会更严格）。
			4、全局包含局部 局部在全局里面 类似于父子级关系。
			
		 	注意：
		 		全局只有一个 局部可以有一堆  而这一堆的局部作用域 又可以使 兄弟 父子 爷孙 祖孙关系 (就是 ul li ，div ul li  ，  li li )。
		 		
		 	
		<b>一、ES5中的作用域</b>
		如：	var a = 3; //全局变量
		
		变量的赋值过程：
			引擎 • 从头到尾负责整个 JavaScript 程序的编译及执行过程。
			
			编译器 • 引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。
			
			作用域 • 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查
			询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
			
		遇到 var a ，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的
			集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
			用域的集合中声明一个新的变量，并命名为 a 。
			
			2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 3 这个赋值
			操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的
			变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。
			
			如果引擎最终找到了 a 变量，就会将 3 赋值给它。否则引擎就会举手示意并抛出一个异
			常！
			
			总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如
			果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对
			它赋值。
			
		编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是
			否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。
			在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS。
			
		换句话说，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

		RHS: 查询与简单地查找某个变量的值别无二致.
		LHS: 查询则是试图找到变量的容器本身，从而可以对其赋值。
		
		在概念上可以将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。
		
            function fn(b){ //局部变量
                c = 2; //全局变量
                var d = 5; //局部变量
                function subFn(){
                    var e = d; //父函数的局部变量对子函数可见
                    for(var i = 0; i < 3; i++){
                        console.write(i);
                    }
                    alert(i);//3, 在for循环内声明，循环外function内仍然可见，没有块作用域
                }
            }
            alert(c); //在function内声明但不带var修饰，仍然是全局变量
            
            
        又如:
			for(var i = 0; i < 10; i++){
				
			}
			console.log(i); //10
			
			//js这段代码，你觉得会输出什么？答案是10，熟悉java、C、C++的同学肯定有点诧异找不到i，为什么会这样呢？
			//因为js还是不同与java的，在ES5中，只有全局作用域和函数作用域，并没有块作用域，当然我们可以实现块作用域的功能。看下面代码:
			(function(){
				for(var j = 0; j < 10; j++){
				
				}
			})()
			//console.log(j); //j is not defined
			
			//这种写法叫做立即调用函数表达式（IIFE），这其实就创建了一个局部作用域，该作用域声明的变量只有在该函数块内有效，外部访问不了。这种写法的好处就是可以做到不污染全局变量(闭包就是如此)。 
			//这里还想再提一点，就是在ES5中，变量的声明问题，不是很严格，你可以直接采用a=10,来声明一个全局变量。如下：
			
			a = 100;
			console.log(a); //100
			
			//这里你可以不声明变量就去使用它，其实js帮你做了一件事。它会执行如下代码:
			
			var a = undefined;
			a = 100;
			console.log(a); //100
			
			//你可以试验一下，在函数中也可以做到不用声明变量直接使用，个人觉得这种灵活的做法不是很好。不过在ES6中，已经不推荐不声明变量就去使用的做法了。 
			//那么我们接下来来一点进阶的东西，就是变量提升。（ES5中的概念，ES6中新的用法不会出现变量提升），看代码:
			
			b = 123;
			(function(){
				console.log(b); //undefined
				var b = 456;
				console.log(b); //456
			})();
			
			//你猜输出什么？undefined,我们来看一下什么是变量提升，很简单，其实就是将变量的声明提升到函数的最上面。其实上面的代码在最后js在解释（Js代码分为两个阶段：编译阶段和执行阶段）【这里是编译阶段】的时候就会变成这个样子：
						
			var b = undefined;
				b = 123;
			(function(){
				var b = undefined;
				console.log(b); //undefined
				b = 456;
				console.log(b); //456
			})();
			
			
			console.log(a); //undefined
            var a = 3;
            console.log(a); //3
            console.log(b); //Uncaught ReferenceError: b is not defined
            
			上面代码在执行前var a=3; 的声明部分就已经得到预解析（但是不会执行赋值语句），所以第一次的时候会是undefined而不会报错，执行过赋值语句后会得到3，上段代码去掉最后一句和下面代码是一样的效果。
			
			var a;
            console.log(a); //undefined
            a = 3;
            console.log(a); //3
			
			//理解了变量提升是什么意思了吧，其实就是将声明提到了最前面，所以输出的是undefined，注：在ES6中就不存在了;
			
			
		<b>然而：
			如果只是这样那么JavaScript作用域问题就很简单了，然而由于函数子函数导致的问题使作用域不止这样简单。
			
			大人物登场——执行环境或者说运行期上下文（好土鳖）：<i>执行环境（execution context）定义了变量或函数有权访问的其它数据，决定了它们的各自行为。</i>
			
			每个执行环境都有一个与之关联的变量对象（variable object, VO），执行环境中定义的所有变量和函数都会保存在这个对象中，解析器在处理数据的时候就会访问这个内部对象。

			全局执行环境是最外层的一个执行环境，在web浏览器中全局执行环境是window对象，因此所有全局变量和函数都是作为window对象的属性和放大创建的。
			
			<i>每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会被推入一个函数栈中，而在函数执行完毕后执行环境出栈并被销毁，保存在其中的所有变量和函数定义随之销毁，</i>
			
			控制权返回到之前的执行环境中，<i>全局的执行环境在应用程序退出（浏览器关闭）才会被销毁。</i>
			
		</b>
			
		<b>二、ES6中的作用域 </b>
			//由于ES5中存在很多问题，所以在ES6中，用let替换了var的声明，不过为了兼容ES5你还是可以使用以前的var。不过还是建议使用let（在移动端ios5及以下的不能识别）
			
		注：在ES5中其是也有块级作用域的：它们是：
			1、with 语句可以方便地用来引用某个特定对象中已有的属性，但是不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。  
			所以： 用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。
			
			function Lakers() {  
			       this.name = "kobe bryant";  
			       this.age = "28";  
			       this.gender = "boy";  
			}  
			var people=new Lakers();  
			with(people)  
			{  
			       var str = "姓名: " + name + "<br>";  
			       str += "年龄：" + age + "<br>";  
			       str += "性别：" + gender;  
			       document.write(str);  
			}
			
			2、 try/catch
			非常少有人会注意到 JavaScript 的 ES3 规范中规定 try / catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。
			
			try {
				undefined(); // 执行一个非法操作来强制制造一个异常
			}
			catch (err) {
				console.log( err ); // 能够正常执行！
			}
			
			console.log( err ); // ReferenceError: err not found
			正如你所看到的， err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。
			
			
		//let为js添加了新的作用域就是块作用域。看代码：
			
			块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息!!!
			
			for(let k = 0; k < 20; k++){
				
			}
			//console.log(k); // k is not defined
			
			//输出 k is not defined, 这里，我们就完全可以使用java等语言，来理解变量的声明了，而且使用let声明的变量，在没声明时（在ES6 严格模式 'use strict'【IE9及以下，不支持严格模式】），是不可以使用的。
			
			c = 3;
			let c = 10;
			console.log(c); //c is not defined

			//将会输出c is not defined,为什么呢？阮一峰的ES6上这样说，只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
			//ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
			//当然他解释为什么的时候提到了暂时性死区,建议看一下他的ES6 http://es6.ruanyifeng.com/#docs/let
			//总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
			
			
			//因为ES6出现的时间不是很长，所以我们还是会遇到很多ES5的写法和用法，
			//所以了解JS es5 和 es6都很重要，不管是做前端还是后端，都会或多或少接触js，既然接触了，我们就要对它有深入的了解才行，不能仅仅停留在写function上面，另外前端已经不像以前的了，我还是很看好js的发展的。
			
		
		<b>作用域嵌套</b>
			由于作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个 作用域。
			
			当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。
			因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止
			
		如:
			function foo(a) {
				console.log( a + b );
			}
			var b = 2;
			foo( 2 ); // 4
			对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成
			
		注:
			遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。
			当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止.
			
			如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。值得注意的是， ReferenceError 是非常重要的异常类型。

			相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，
			全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。
			
			
		<b>小结</b>
			作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。

			赋值操作符会导致 LHS 查询。 ＝ 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。
			
			JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声
			
			明会被分解成两个独立的步骤：
				1. 首先， var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
				2. 接下来， a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。
				
			LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。
			
			不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。
		</pre>
	</body>
	
	<script type="text/javascript">
		//一、ES5中的作用域

		/*
			注：无论是ES5 还是 ES6
				如果用var声明变量，只有就全局作用域 和 函数作用域
				if(true) {
					var x = 100;
				}
				console.log(x) // 100


				如果用let声明变量，就有就全局作用域 和 函数作用域 以及 块级作用域{}
				if(true) {
					let x = 100;
				}
				console.log(x) // ReferenceError：x is not defined 
		*/

			//先看代码：
			for(var i = 0; i < 10; i++){
				
			}
			console.log(i); //10
			
			//js这段代码，你觉得会输出什么？答案是10，熟悉java、C、C++的同学肯定有点诧异找不到i，为什么会这样呢？
			//因为js还是不同与java的，在ES5中，只有全局作用域和函数作用域，并没有块作用域，当然我们可以实现块作用域的功能。看下面代码:
			(function(){
				for(var j = 0; j < 10; j++){
				
				}
			})()
			//console.log(j); //j is not defined
			
			//这种写法叫做立即调用函数表达式（IIFE），这其实就创建了一个局部作用域，该作用域声明的变量只有在该函数块内有效，外部访问不了。这种写法的好处就是可以做到不污染全局变量(闭包就是如此)。 
			//这里还想再提一点，就是在ES5中，变量的声明问题，不是很严格，你可以直接采用a=10,来声明一个全局变量。如下：
			
			a = 100;
			console.log(a); //100
			
			//这里你可以不声明变量就去使用它，其实js帮你做了一件事。它会执行如下代码:
			
			var a = undefined;
			a = 100;
			console.log(a); //100
			
			//你可以试验一下，在函数中也可以做到不用声明变量直接使用，个人觉得这种灵活的做法不是很好。不过在ES6中，已经不推荐不声明变量就去使用的做法了。 
			//那么我们接下来来一点进阶的东西，就是变量提升。（ES5中的概念，ES6中新的用法不会出现变量提升），看代码:
			
			b = 123;
			(function(){
				console.log(b); //undefined
				var b = 456;
				console.log(b); //456
			})();
			
			//你猜输出什么？undefined,我们来看一下什么是变量提升，很简单，其实就是将变量的声明提升到函数的最上面。其实上面的代码在最后js在解释（Js代码分为两个阶段：编译阶段和执行阶段）【这里是编译阶段】的时候就会变成这个样子：
			
			var b = undefined;
				b = 123;
			(function(){
				var b = undefined;
				console.log(b); //undefined
				b = 456;
				console.log(b); //456
			})();
			
			//理解了变量提升是什么意思了吧，其实就是将声明提到了最前面，所以输出的是undefined，注：在ES6中就不存在了;
			
			
			
		//二、ES6中的作用域 
			//由于ES5中存在很多问题，所以在ES6中，用let替换了var的声明，不过为了兼容ES5你还是可以使用以前的var。不过还是建议使用let（在移动端ios5及以下的不能识别）
			//let为js添加了新的作用域就是块作用域。看代码：
			
			for(let k = 0; k < 20; k++){
				
			}
			//console.log(k); // k is not defined
			
			//输出 k is not defined, 这里，我们就完全可以使用java等语言，来理解变量的声明了，而且使用let声明的变量，在没声明时（在ES6 严格模式 'use strict'【IE9及以下，不支持严格模式】），是不可以使用的。
			
			c = 3;
			let c = 10;
			console.log(c); //c is not defined

			//将会输出c is not defined,为什么呢？阮一峰的ES6上这样说，只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
			//ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
			//当然他解释为什么的时候提到了暂时性死区,建议看一下他的ES6 http://es6.ruanyifeng.com/#docs/let
			//总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
			
			
			//因为ES6出现的时间不是很长，所以我们还是会遇到很多ES5的写法和用法，
			//所以了解JS es5 和 es6都很重要，不管是做前端还是后端，都会或多或少接触js，既然接触了，我们就要对它有深入的了解才行，不能仅仅停留在写function上面，另外前端已经不像以前的了，我还是很看好js的发展的。
	</script>
</html>
