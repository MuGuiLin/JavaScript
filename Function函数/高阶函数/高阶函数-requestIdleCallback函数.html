<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>高阶函数-requestIdleCallback函数</title>
    <style>
        h1 {
            text-align: center;
        }
    </style>
</head>

<body>
    <h1>高阶函数-requestIdleCallback函数</h1>
    <hr>
    <pre>
        RequestIdleCallback
        简单的说，判断一帧有空闲时间，则去执行某个任务。目的是为了解决当任务需要长时间占用主进程，导致更高优先级任务(如动画或事件任务)，无法及时响应，而带来的页面丢帧(卡死)情况。故RequestIdleCallback 定位处理的是:
        不重要且不紧急的任务。

        了解更多：https://cloud.tencent.com/developer/article/2436905
    </pre>
    <button id="insert-btn">插入100000个DIV元素 - 普通插入</button>
    <button id="insert-btn2">插入100000个DIV元素 - 高阶函数插入</button>
    <button id="insert-btn3">插入100000个DIV元素 - 通用高阶函数插入</button>

    <script>
        // 普通插入
        {   
            const insert_btn = document.querySelector('#insert-btn');
            const data = new Array(100000).fill(0).map((_, i) => i);

            insert_btn.onclick = () => {
                for (const i of data) {
                    const div = document.createElement('div');
                    div.innerText = i;
                    document.body.append(div);
                }
            }
        };

        // 高阶函数插入
        {
            const insert_btn = document.querySelector('#insert-btn2');
            const data = new Array(100000).fill(0).map((_, i) => i);

            insert_btn.onclick = () => {
                // 调用高阶函数
                performChunk(data, (item, i) => {
                    const div = document.createElement('div');
                    div.innerText = i;
                    document.body.append(div);
                })
            }

            function performChunk(data, call) {
                if (0 === data.length) {
                    return;
                }
                let i = 0;

                function _run() {
                    // 循环任务结束
                    if (i >= data.length) {
                        return
                    }

                    // requestIdleCallback 是浏览器原生API（Node.js环境没有）, 一个渲染帧中，空闲时开启分片执行， 16.6ms的空闲时间
                    requestIdleCallback((idel) => {
                        console.log('idel', idel)
                        // 当渲染帧有空闲剩余时间，并且还有循环任务时
                        while (0 < idel.timeRemaining() && i < data.length) {
                            call(data[i], i)
                            i++
                        }
                        // 本次分片完成后，递归调用
                        _run()
                    })
                }
                _run();
            }
        };

         // 通用高阶函数插入
         {
            const insert_btn = document.querySelector('#insert-btn3');
            const data = new Array(100000).fill(0).map((_, i) => i);

            insert_btn.onclick = () => {
                // 调度器
                const scheduler = (task) => {
                    // 分片（任务间隔调用）
                    setTimeout(() => {
                        const now = performance.now();
                        // 设置每个分片要执行的时间
                        task(() => performance.now() - now <= 10)
                    }, 1000);
                }
                // 调用高阶函数
                performChunk(data, (item, i) => {
                    const div = document.createElement('div');
                    div.innerText = i;
                    document.body.append(div);
                }, scheduler)
            }

            function performChunk(data, call, scheduler) {
                if (0 === data.length) {
                    return;
                }
                let i = 0;

                function _run() {
                    // 循环任务结束
                    if (i >= data.length) {
                        return
                    }

                    // 任务调度器
                    scheduler((goOn) => {
                        // 当渲染帧有空闲剩余时间，并且还有循环任务时
                        while (goOn() && i < data.length) {
                            call(data[i], i)
                            i++
                        }
                        // 本次分片完成后，递归调用
                        _run()
                    })
                }
                _run();
            }
        }

    </script>
</body>

</html>